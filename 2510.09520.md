# Big cats: entanglement in 120 qubits and beyond

[arxiv.org/2510.09520](https://arxiv.org/abs/2510.09520)

### Problem / State of the Art

Preparing and **certifying** large-scale multipartite entanglement (e.g., GHZ “cat” states) is both a practical benchmark of quantum hardware and a resource for algorithms/metrology—but GHZ states are notoriously fragile and hard to scale. Prior superconducting records trailed this work by dozens of qubits; traditional verification (MQC/parity oscillations) also scales poorly and is readout-sensitive.

### Goal

Demonstrate and certify a **record-size GHZ state** on a superconducting platform while keeping depth and errors in check, and provide a scalable **compilation + verification** workflow that copes with non-uniform hardware and readout limitations. On **ibm_aachen**, they target ~120 data qubits plus dedicated check ancillas, and certify fidelity > 0.5 (genuine N-partite entanglement). See title/abstract and the overview on **p.1**, and **Fig. 1** on **p.2**.

### Challenges

- **Hardware non-uniformity**: “tail” qubits/gates and layout constraints break naïve BFS trees and ancilla placement. (p.2–3)
- **Readout errors** can dominate fidelity estimation, blurring state quality vs. measurement quality. (p.1, p.4)
- **Z-type (dephasing) errors** accumulate in long idle windows typical of tree-like GHZ builds. (p.3, App. B p.7–8)
- **Verification scaling**: MQC/parity oscillations require many circuits; DFE demands high-weight Pauli expectations with reliable mitigation. (p.1, p.4)

### Key Mechanism (What they actually do)

1. **Adaptive GHZ compiler on the hardware graph**
   - Root at a vertex of near-minimal eccentricity and grow a **BFS tree** to minimize CNOT depth $D_{\text{GHZ}} \lesssim \text{radius}(G)$. (Eq. (2), p.3)
   - **Randomized blocking** during BFS to carve space for ancillas and avoid weak links. (p.3)
   - Choose parity-check pairs to maximize **coverage** (fraction of spacetime locations where X/Y errors are detected). (Lemma 1 + “ZZ back-propagation,” p.3; **Fig. 1** p.2).

2. **Low-overhead ZZ parity checks + post-selection**
   - Use **8 ancillas** to measure (Z_iZ_j) parities that flag X/Y errors along paths to the **lowest common ancestor** of the checked leaves; discard failing runs. (p.2–3; **Fig. 1a–b** p.2)

3. **Temporary uncomputation** to fight dephasing
   - **ASAP uncompute / ALAP recompute** early nodes so they relax in $\lvert 0\rangle$ during long idle spans (plus **dynamical decoupling**). (p.3; App. B + **Fig. 3** p.8)

4. **Readout-aware fidelity estimation**
   - Run **Parity Oscillations** (coherence $\chi$ via the Fourier transform of $M_\phi$) + direct **DFE** over GHZ stabilizers; show the two are **theoretically equivalent** and empirically agree. Use **TREX** (expectation-value) and **M3** (bitstring) mitigation appropriately. (p.4–5; App. A p.7)
   - **Fig. 2** (p.5) shows parity fringes/Fourier spike and DFE bars lining up; **Table I** (p.5) summarizes cross-device results.

### Key Results

- **120-qubit GHZ** (plus 8 ancillas for checks) on **ibm_aachen** with **CNOT depth ≈ 18** (see **Fig. 1a** timeline), **DFE fidelity (F=0.56(3))** with **post-selection rate ≈ 0.28**. (p.1–2)
- **Method equivalence**: On **ibm_kingston (100 qubits)**, parity-oscillation fidelity ($F\approx 0.536(8)$) vs. **DFE ($F=0.55(3)$)**—agreement within error bars; a phase offset is visible in the Fourier spectrum. (**Fig. 2**, p.5)
- **Cross-QPU reproducibility** at 100 qubits: DFE fidelities **0.70(4)/0.55(3)/0.46(4)** with post-selection **0.36/0.28/0.14** on **ibm_kobe/kingston/fez** (**Table I**, p.5). With additional non-Markovian post-selection on **fez**, **0.68(3)** at retention **0.04**. (p.6)

### Strengths

- **Hardware-aware, coverage-optimized compilation** that natively handles irregular connectivity and ancilla proximity. (p.2–3)
- **Clear, practical error-mitigation stack**: (ZZ checks + post-selection) ⊕ (temporary uncomputation + DD) ⊕ (TREX/M3 for readout). (p.2–4, App. A–B)
- **Verification clarity & redundancy**: two independent routes (parity oscillations, DFE) shown **analytically equivalent** and **experimentally consistent**; helpful diagnostics like phase extraction from the fringe. (p.4–5; App. C)
- **Record scale with moderate depth** (depth ~18) and decent retention (~28%). (**Fig. 1**, p.2)

### Improvements / Questions

- **Cost–benefit of post-selection**: Retention 0.28 (and 0.04 with aggressive filtering) is workable for benchmarking, but algorithmic use may need throughput analysis and batching/parallelization details. (p.1–2, p.6)
- **Coverage metric vs. alternative objectives**: Great intuition, but some ablation on _how much_ randomized blocking and coverage optimization contribute (vs. uncomputation or DD) would help isolate gains. (p.3, App. B fig)
- **Scalability to non-GHZ stabilizer states**: Authors note parity checks become harder; a concrete case study (e.g., graph/cluster states with low-weight _spacetime_ checks) would strengthen the “beyond GHZ” outlook. (p.6)
- **Readout-mitigation robustness**: TREX vs. M3 choices are motivated, but a sensitivity sweep (error bars vs. mitigation depth/calibration drift) would clarify reliability under day-to-day changes. (App. A p.7)
- **Resource reporting**: A concise budget table (gate counts, single/two-qubit error rates used by the compiler, ancilla routing overhead) would aid reproducibility across labs.

### What I Learned / Liked

- The **“detecting region” via ZZ back-propagation** (Lemma 1) is an elegant way to **score checks by their spacetime coverage**; it explains why some intuitive checks underperform (e.g., neighbors with trivial LCA). (p.3; **Fig. 1** p.2)
- **Temporary uncomputation** + **DD** is a simple, powerful pattern for tree-like entanglers. The **timeline overlays** in **Fig. 3 (p.8)** make the Z-error suppression story very concrete.
- The **DFE ↔ parity-oscillation equivalence** neatly ties experiment-friendly signals to stabilizer averages, giving two levers for certification. (p.4–5; App. C)

### Summary Brief

The paper compiles **record-scale GHZ states (120 qubits)** on IBM superconducting hardware by **growing** the GHZ tree directly on the device graph, **maximizing error-detection coverage** with strategically placed **ZZ parity checks**, and **shortening dephasing windows** via **temporary uncomputation** (plus **DD**). It then **certifies fidelity** using **parity oscillations** and **direct fidelity estimation**, proves these are **equivalent**, and shows strong **experimental agreement**. Headline result: **(F=0.56(3))** with **~28%** retention at **depth ≈ 18**, plus reproducible 100-qubit benchmarks across multiple QPUs. The approach is a practical template for **hardware-aware compilation + error-detection + readout-mitigated verification** of large entangled resource states. (See **Fig. 1** p.2; **Fig. 2** & **Table I** p.5; **App. B–C**.)
